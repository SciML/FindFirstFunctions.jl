var documenterSearchIndex = {"docs":
[{"location":"#FindFirstFunctions.jl","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"","category":"section"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"FindFirstFunctions.jl is a library for accelerated findfirst type functions.","category":"page"},{"location":"#Installation","page":"FindFirstFunctions.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"To install FindFirstFunctions.jl, use the Julia package manager:","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"using Pkg\nPkg.add(\"FindFirstFunctions\")","category":"page"},{"location":"#Available-Functions","page":"FindFirstFunctions.jl","title":"Available Functions","text":"","category":"section"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"FindFirstFunctions.findfirstequal\nFindFirstFunctions.bracketstrictlymontonic\nFindFirstFunctions.looks_linear\nFindFirstFunctions.Guesser\nFindFirstFunctions.searchsortedfirstcorrelated\nFindFirstFunctions.searchsortedlastcorrelated\nFindFirstFunctions.findfirstsortedequal","category":"page"},{"location":"#FindFirstFunctions.findfirstequal","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.findfirstequal","text":"findfirstequal(x::Int64,A::DenseVector{Int64})\n\nFinds the first value in A equal to x\n\n\n\n\n\n","category":"function"},{"location":"#FindFirstFunctions.bracketstrictlymontonic","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.bracketstrictlymontonic","text":"bracketstrictlymontonic(v, x, guess; lt=<comparison>, by=<transform>, rev=false)\n\nStarting from an initial guess index, find indices (lo, hi) such that v[lo] ≤ x ≤ v[hi] according to the specified order, assuming that x is actually within the range of values found in v.  If x is outside that range, either lo will be firstindex(v) or hi will be lastindex(v).\n\nNote that the results will not typically satisfy lo ≤ guess ≤ hi.  If x is precisely equal to a value that is not unique in the input v, there is no guarantee that (lo, hi) will encompass all indices corresponding to that value.\n\nThis algorithm is essentially an expanding binary search, which can be used as a precursor to searchsorted and related functions, which can take lo and hi as arguments.  The purpose of using this function first would be to accelerate convergence in those functions by using correlated guesses for repeated calls.  The best guess for the next call of this function would be the index returned by the previous call to searchsorted.\n\nSee Base.sort! for an explanation of the keyword arguments by, lt and rev.\n\n\n\n\n\n","category":"function"},{"location":"#FindFirstFunctions.looks_linear","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.looks_linear","text":"looks_linear(v; threshold = 1e-2)\n\nDetermine if the abscissae v are regularly distributed, taking the standard deviation of the difference between the array of abscissae with respect to the straight line linking its first and last elements, normalized by the range of v. If this standard deviation is below the given threshold, the vector looks linear (return true). Internal function - interface may change.\n\n\n\n\n\n","category":"function"},{"location":"#FindFirstFunctions.Guesser","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.Guesser","text":"Guesser(v::AbstractVector; looks_linear_threshold = 1e-2)\n\nWrapper of the searched vector v which makes an informed guess  for searchsorted*correlated by either\n\nExploiting that v is sufficiently evenly spaced\nUsing the previous outcome of searchsorted*correlated \n\n\n\n\n\n","category":"type"},{"location":"#FindFirstFunctions.searchsortedfirstcorrelated","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.searchsortedfirstcorrelated","text":"searchsortedfirstcorrelated(v::AbstractVector, x, guess)\n\nAn accelerated findfirst on sorted vectors using a bracketed search. Requires a guess::Union{<:Integer, Guesser} to start the search from.\n\n\n\n\n\n","category":"function"},{"location":"#FindFirstFunctions.searchsortedlastcorrelated","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.searchsortedlastcorrelated","text":"searchsortedlastcorrelated(v::AbstractVector{T}, x, guess)\n\nAn accelerated findlast on sorted vectors using a bracketed search. Requires a guess::Union{<:Integer, Guesser} to start the search from.\n\n\n\n\n\n","category":"function"},{"location":"#FindFirstFunctions.findfirstsortedequal","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.findfirstsortedequal","text":"findfirstsortedequal(vars::DenseVector{Int64}, var::Int64)::Union{Int64,Nothing}\n\nNote that this differs from searchsortedfirst by returning nothing when absent.\n\n\n\n\n\n","category":"function"},{"location":"#Contributing","page":"FindFirstFunctions.jl","title":"Contributing","text":"","category":"section"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"FindFirstFunctions.jl","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"</details>","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"</details>","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"</details>","category":"page"},{"location":"","page":"FindFirstFunctions.jl","title":"FindFirstFunctions.jl","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
